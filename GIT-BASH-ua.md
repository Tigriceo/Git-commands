# Шпаргалка з bash

### Додайте свої команди та інші корисності через `Pull request`.

Шпаргалка основних команд Git Bash, терміналу OSX, терміналу linux.

## Суть

Консоль — зручний та швидкий інструмент керування комп'ютером. Вводимо команду текстом, отримуємо результат чи повідомлення про помилку із зазначенням у чому помилка.

Працюючи з консоллю, ми завжди «перебуваємо» в якійсь папці (це вказано у рядку над курсором). Якщо там написано `~`, то ми в папці користувача (залежить від налаштувань Windows, найчастіше це `C:/Users/ВАШЕ ІМ'Я КОРИСТУВАЧА/`), якщо там `/d/projects`, ми в папці `D:/projects` .

## Файлова система

### Перегляд вмісту папки

``` bash
pwd # виводить поточний шлях (скорочення від PRINT WORK DIRECTORY)
ls # показати вміст папки
ls -l # відображає розширену інформацію про файли та папки
ls -a # те ж, але показувати і приховані файли та папки
ls -a -1 # те саме, але в один стовпець
ls -hF -1 --sort=extension # показати вміст папки «красиво, в один стовпець»
ls build/css # показати вміст папки ПОТОЧНА_ПАПКА/build/css
ls /d/projects # показати вміст папки D:/projects
````

### Переміщення файловою системою

Користувач завжди знаходиться в якійсь папці, вона (або повна дорога) завжди показана до області введення команд.

``` bash

cd projects # перехід до папки projects, яка є поточною папкою
cd /d/projects # windows: перехід до папки projects, розташованої за адресою D:/projects
cd /c/Program\ Files # windows: перехід у C/:Program Files
cd. # поточна директорія
cd .. # перехід до батьківської папки
cd ~ # домашня директорія
cd - # перехід до останньої робочої папки
````

Щоб не набирати ім'я папки повністю, наберіть першу пару символів і натисніть <kbd>Tab</kbd> — відбудеться автодоповнення (якщо немає двох папок, що починаються з введених символів, інакше будуть показані самі ці папки). Справедливо для будь-якої команди.

### Створення папок та файлів

``` bash
mkdir project # створити папку з ім'ям «project»
mkdir project project/css project/js # створити кілька папок
mkdir -p project/{css,js} # те саме, що вище

touch index.html # створити файл
touch index.html css/style.css js/script.js # створити файли (папки css/ та js/ повинні вже існувати)
````

### Копіювання файлів

``` bash
cp index.html catalog.html # копіювання файлу index.html у той же каталог з перейменуванням на catalog.html
cp index.html old/ # копіювання файлу index.html до папки old/ (все відбудеться в поточній папці)
cp temp/ temp2/ -r # дублювання каталогу
````


### Перейменування або переміщення файлів

``` bash
mv index.html old # переміщення файлу до папки
mv index.html old/new_name.txt # переміщення файлу в папку з перейменуванням файлу
mv order.txt orderNew.txt # перейменувати файл
````


### Видалення папок та файлів

``` bash
rm ghost.png # видалити файл
rm -rf old # видалити папку та все з неї
````


## Аліаси

Для команд можна створювати аліаси (синоніми).
Для цього в папці користувача (OSX і linux) або в C:/Users/ІМ'Я_КОРИСТУВАЧА/.bashrc (Windows) потрібно вписати рядки, на зразок alias pro='cd /d/projects' (один рядок у файлі - один аліас).

``` bash
alias # відобразить аліаси, які вже задані в системі
alias c='clear' # створить аліас який очищатиме консоль
unalias c # видалить аліас "c"
unalias -a # видалить усі записані аліаси
````


## Різне

Добірка команд, що показують більшу швидкість роботи з консоллю, ніж з GUI або зручних команд. Багато з них можуть бути реалізовані різними шляхами з GUI, що нітрохи не применшує зручності консолі.

``` bash
clear # очистити консоль
df -h # показати статистику використання простору на дисках
grep -i -n --color 'carousel' index.html css/style.css # знайти слово carousel у двох зазначених файлах (з ігнором регістру), вивести рядки з цим словом та номери рядків (потрібне слово підсвітити)
grep word -r project # знайти слово word у всіх файлах у папці project
find. -iname '*ind*' # знайти в поточній папці (і підпапках) всі файли, імена яких містять ind та показати списком
ls -a >> file.txt # записати у file.txt результат виведення команди ls -a
ls src/less/mixins # показати вміст папки із зазначеним шляхом без переходу до неї
echo "Some text" # виведення тексту в консоль
chmod +x ./fileName # зробити файл виконуваним
whoami # виводить ім'я користувача
````

## Використання змінних
Змінні дозволяють зберігати у файлі сценарію інформацію, наприклад результати роботи команд для використання їх іншими командами.

Існують два типи змінних, які можна використовувати в bash-скриптах:

1. Змінні середовища - змінні встановлені у середовищі
``` bash
echo $HOME
echo "Env variable $HOME"

````
2. Змінні користувача - зберігають значення до тих пір, поки не завершиться виконання сценарію.

``` bash
#!/bin/zsh

grade=5
person="Adam"
echo "$person is a good boy, he is in grade $grade"
````
## Підстановка команд у змінні

Одна з найкорисніших можливостей bash-скриптів - це можливість витягувати інформацію з виведення команд і призначати її змінним, що дозволяє використовувати цю інформацію де завгодно у файлі сценарію.

Зробити це можна двома способами.

1. За допомогою піктограми зворотного апострофа «`»
``` bash
mydir = `pwd`
````
2. За допомогою конструкції $()
``` bash
mydir = $ (pwd)
````

А скрипт, зрештою, може виглядати так:
``` bash
#!/bin/bash

mydir = $ (pwd)
echo $mydir
````
У ході його роботи виведення команди pwd буде збережено в змінній mydir, вміст якої за допомогою команди echo потрапить в консоль.

## Математичні операції

Для виконання математичних операцій у файлі скрипта можна використовувати конструкцію виду `$((a+b))`

``` bash
#!/bin/bash

var1=$(( 5 + 5 ))
echo $var1

var2=$(( $var1 * 2 ))
echo $var2
````

## Керуюча конструкція if-then

У деяких сценаріях потрібно керувати потоком виконання команд. Наприклад, якщо якесь значення більше п'яти, потрібно виконати одну дію, інакше інше. Подібне застосовується в багатьох ситуаціях, і тут нам допоможе керуюча конструкція if-then. У найпростішому вигляді вона виглядає так

``` bash
if команда
then
команди
fi

#!/bin/bash
if pwd
then
echo "It works"
fi
````

Приклад: треба знайти якогось користувача в `/etc/passwd`, і якщо знайти його вдалося, повідомити, що він існує.

``` bash
#!/bin/bash

user=likegeeks
if grep $user /etc/passwd
then
echo "The user $user Exists"
fi
````

## Керуюча конструкція if-then-else

Для того, щоб програма змогла повідомити і результати успішного пошуку, і про невдачу, скористаємося конструкцією `if-then-else`. Ось як вона влаштована:

``` bash
if команда
then
команди
else
команди
fi
````
Якщо перша команда поверне нуль, що означає її успішне виконання, умова виявиться істинною і виконання не піде гілкою else. В іншому випадку, якщо буде повернуто щось, що відрізняється від нуля, що означатиме невдачу, або помилковий результат, будуть виконані команди, розташовані після else.

``` bash
#!/bin/bash

user=anotherUser
if grep $user /etc/passwd
then
echo "The user $user Exists"
else
echo "The user $user doesn't exist"
fi
````

## Конструкція CASE
Якщо ви зіткнулися з парою різних можливих дій, то використання оператора case може бути кориснішим, ніж вкладені оператори if. Для більш складних умов використовуйте приклад, як показано нижче
``` bash
case "$extension" in
   "jpg"|"jpeg") echo "It's image with jpeg extension." ;;;
   "png") echo "It's image with png extension." ;;;
   "gif") echo "Oh, it's a giphy!" ;;;
   *) echo "Woops! It's not image!" ;;;
esac
````

## Цикли

У Bash є чотири типи циклів: for, while, until і select.

- FOR
``` bash
#1
for arg in elem1 elem2 ... elemN
do
   # statements
done

# 2
for i in {1..5}; do echo $i; done

#3
for (( i = 0; i < 10; i++ )); do
   echo $i
done

# 4
for FILE в $HOME/*.bash; do
   mv "$FILE" "${HOME}/scripts"
   chmod +x "${HOME}/scripts/${FILE}"
done
````

- WHILE - Цикл while перевіряє умову та перебирає послідовність команд, поки ця умова істинна. Умова - це не що інше, як первинне значення, яке використовується в умовах if..then.
``` bash
while [[ condition ]]
do
   # statements
done

# Squares of numbers from 0 through 9
x=0
while [[$ x -lt 10]]; do # value of x is less than 10
   echo $(( x * x ))
   x=$(( x + 1 )) # increase x
done
````

- UNTIL - цикл until - повна протилежність циклу while. Якийсь час він перевіряє умову тесту, але продовжує цикл, поки ця умова хибна
``` bash
until [[condition]]; do
   #statements
done
````
- SELECT - Цикл вибору допомагає нам організувати меню користувача. Він має майже той же синтаксис, що і цикл
``` bash
select answer in elem1 elem2 ... elemN
do
   # statements
done
````
У цьому прикладі користувач запитує, який диспетчер пакетів він хотів би використовувати. Потім він запитає, який пакет ми хочемо встановити, і, нарешті, розпочне його встановлення.

```sh
PS3="Choose the package manager: "
select ITEM in bower npm gem pip
do
   echo -n "Enter package name: " && read PACKAGE
   case $ITEM in
     bower) bower install $PACKAGE;;
     npm) npm install $PACKAGE;;
     gem) gem install $PACKAGE;;
     pip) pip install $PACKAGE;;
   esac
   break # avoid infinite loop
done
````

- LOOP CONTROL - Бувають ситуації, коли нам потрібно зупинити цикл до нормального завершення або переступити через ітерацію. У цих випадках ми можемо використовувати вбудовані в оболонку оператори break та continue.

Оператор `break` використовується для виходу з поточного циклу до його завершення
Оператор `continue` проходить одну ітерацію
```sh
for (( i = 0; i < 10; i++ )); do
   if [[$((i %2)) -eq 0]]; then continue; fi
   echo $i
done
````

## Порівняння чисел

У скриптах можна порівнювати числові значення. Нижче наведено список відповідних команд.

Порівняння пишемо в [ ] обов'язково прогалини в дужках
 
``` bash
# eq - equal
# ge - greater equal
# gt - greater than
# le - less equal
# lt - less than
# ne - not equal

n1 -eq n2 # Повертає справжнє значення, якщо n1 дорівнює n2.
n1 -ge n2 # Повертає справжнє значення, якщо n1 більше або дорівнює n2.
n1 -gt n2 # Повертає справжнє значення, якщо n1 більше за n2.
n1 -le n2 # Повертає справжнє значення, якщо n1 менше або дорівнює n2.
n1 -lt n2 # Повертає справжнє значення, якщо n1 менше n2.
n1 -ne n2 # Повертає справжнє значення, якщо n1 не дорівнює n2.

val1=6
if [ $ val1 -gt 5 ]
then
echo "The test value $val1 is greater than 5"
else
echo "Тест value $val1 is not greater than 5"
fi
````

## Порівняння рядків

У сценаріях можна порівнювати рядкові значення.
Оператори порівняння виглядають досить просто, проте операції порівняння рядків мають певні особливості, яких ми торкнемося нижче. Ось перелік операторів.

``` bash
str1 = str2 # Перевіряє рядки на рівність, повертає істину, якщо рядки ідентичні.
str1 != str2 # Повертає істину, якщо рядки не ідентичні.

# оператори «>» і «<» необхідно екранувати за допомогою зворотної косої межі,
str1 \< str2 # Повертає істину, якщо str1 менше, ніж str2.
str1 \> str2 # Повертає істину, якщо str1 більше, ніж str2.

-n str1 # Повертає істину, якщо довжина str1 більша за нуль.
-z str1 # Повертає істину, якщо довжина str1 дорівнює нулю.

#!/bin/bash

user ="likegeeks"
if [ $user = $USER ]
then
echo "The user $user is the current logged in user"
fi
````

## Перевірки файлів

Команди дозволяють перевіряти різні умови щодо файлів

``` bash
-d file # Перевіряє, чи існує файл, і чи він є директорією.
-e file # Перевіряє, чи існує файл.
-f file # Перевіряє, чи існує файл, і чи він є файлом.
-r file # Перевіряє, чи існує файл, і чи він доступний для читання.
-s file # Перевіряє, чи існує файл, і чи він не порожній.
-w file # Перевіряє, чи існує файл, і чи він доступний для запису.
-x file # Перевіряє, чи існує файл, і чи він виконуваний.
file1 -nt file2 # Перевіряє, чи новіший file1, ніж file2.
file1 -ot file2 # Перевіряє, чи старше file1, ніж file2.
-O file # Перевіряє, чи існує файл і чи є його власником поточний користувач.
-G file # Перевіряє, чи існує файл і чи відповідає його ідентифікатор групи ідентифікатору групи поточного користувача.

#!/bin/bash

mydir=/home/likegeeks

if [ -d $mydir ] # якщо файл є і він є директорією
then
echo "The $mydir directory exists" # виводимо повідомлення
cd $mydir # переходимо до нього
ls # відображаємо вміст
else # Інакше
echo "The $mydir directory не існує"
fi
````

## Оператори

Пайпи **|** - передає результат виконаної інструкції наступному пайпу
``` bash
# command1 | command2 | command3
ls -l | grep .md$ | less
````

Крапка з комою **;** - виконує команди послідовно
``` bash
# command2 will be executed after command1
command1; command2
````
Амперсанд **&** - оболонка виконує команду асинхронно у підболочці. Іншими словами, ця команда виконуватиметься у фоновому режимі

Подвійний амперсанд (І) **&&** - друга команда буде виконана лише у разі УСПІШНОГО завірення першої команди
``` bash
# command2 will be executed if, і тільки if, command1 finishes successfully (returns 0 exit status)
command1 && command2
````

Подвійний пайп (АБО) - друга команда буде виконана тільки у разі невдалого засвідчення першої команди
``` bash
# command2 will be executed if, і тільки if, command1 finishes unsuccessfully (returns code of error)
command1 || command2
````

Тестові **[ ]** - Ці висловлювання допомагають нам вказати результати умовного виразу. Використовуються зазвичай у блоках if
``` bash
# Single-line
if [[1-eq 1]]; then echo "true"; fi

# Multi-line
if [[1-eq 1]]; then
   echo "true"
fi

# Single-line
if [[2-ne 1]]; then echo "true"; else echo "false"; fi

# Multi-line
if [[2-ne 1]]; then
   echo "true"
else
   echo "false"
fi
````